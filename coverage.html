
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>lambda: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-lambda-api/cmd/lambda/lambda-main.go (0.0%)</option>
				
				<option value="file1">go-lambda-api/cmd/local/main.go (0.0%)</option>
				
				<option value="file2">go-lambda-api/handlers/health_handler.go (0.0%)</option>
				
				<option value="file3">go-lambda-api/handlers/user_handler.go (0.0%)</option>
				
				<option value="file4">go-lambda-api/internal/app/app.go (0.0%)</option>
				
				<option value="file5">go-lambda-api/models/user.go (0.0%)</option>
				
				<option value="file6">go-lambda-api/utils/response.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package lambda

import (
        "context"
        "errors"
        "log"
        "net/http"

        "go-lambda-api/handlers"
        "go-lambda-api/models"
        "go-lambda-api/utils"

        "github.com/aws/aws-lambda-go/events"
)

const (
        UsersIDPath = "/users/{id}"
        RootPath    = "/"
        HealthPath  = "/health"
        UsersPath   = "/users"
)

// Router handles routing of API Gateway requests to appropriate handlers.
func Router(
        ctx context.Context,
        request events.APIGatewayProxyRequest,
        userRepo models.UserRepository,
        healthHandler func(context.Context, events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error),
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        var response events.APIGatewayProxyResponse
        var err error

        // Initialize common headers, including CORS
        commonHeaders := map[string]string{
                "Content-Type":                     "application/json",
                "Access-Control-Allow-Origin":      "*", // Allow all origins for simplicity
                "Access-Control-Allow-Methods":     "GET,POST,PUT,DELETE,OPTIONS",
                "Access-Control-Allow-Headers":     "Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token",
                "Access-Control-Allow-Credentials": "true",
        }

        // Handle OPTIONS pre-flight requests
        if request.HTTPMethod == http.MethodOptions </span><span class="cov0" title="0">{
                return events.APIGatewayProxyResponse{
                        StatusCode: http.StatusOK,
                        Headers:    commonHeaders,
                }, nil
        }</span>

        // Set initial response headers (will be merged later if APIResponse is used)
        <span class="cov0" title="0">response.Headers = commonHeaders

        switch </span>{
        case request.Path == RootPath &amp;&amp; request.HTTPMethod == http.MethodGet:<span class="cov0" title="0">
                response, err = handleRootGet(request)</span>
        case request.Path == HealthPath &amp;&amp; request.HTTPMethod == http.MethodGet:<span class="cov0" title="0">
                response, err = healthHandler(ctx, request)</span>
        case request.Path == UsersPath &amp;&amp; request.HTTPMethod == http.MethodPost:<span class="cov0" title="0">
                response, err = handleCreateUser(ctx, request, userRepo)</span>
        case request.Path == UsersIDPath &amp;&amp; request.HTTPMethod == http.MethodGet:<span class="cov0" title="0">
                response, err = handleGetUser(ctx, request, userRepo)</span>
        case request.Path == UsersPath &amp;&amp; request.HTTPMethod == http.MethodGet:<span class="cov0" title="0">
                response, err = handleGetAllUsers(ctx, request, userRepo)</span>
        case request.Path == UsersIDPath &amp;&amp; request.HTTPMethod == http.MethodPut:<span class="cov0" title="0">
                response, err = handleUpdateUser(ctx, request, userRepo)</span>
        case request.Path == UsersIDPath &amp;&amp; request.HTTPMethod == http.MethodDelete:<span class="cov0" title="0">
                response, err = handleDeleteUser(ctx, request, userRepo)</span>
        default:<span class="cov0" title="0">
                response, err = utils.ErrorResponse(http.StatusNotFound, errors.New("not found"))</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error processing request: %v", err)

                // If an error occurs, preserve the original status code if it's an error from utils.ErrorResponse,
                // otherwise, default to InternalServerError.
                // We also ensure CORS headers are present in the error response.
                statusCode := http.StatusInternalServerError
                if response.StatusCode != 0 &amp;&amp; response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        statusCode = response.StatusCode
                }</span>

                <span class="cov0" title="0">errorResponse, _ := utils.ErrorResponse(statusCode, err)
                for k, v := range commonHeaders </span><span class="cov0" title="0">{
                        errorResponse.Headers[k] = v
                }</span>
                <span class="cov0" title="0">return errorResponse, nil</span>
        }

        // Merge common headers with the handler's response headers
        <span class="cov0" title="0">if response.Headers == nil </span><span class="cov0" title="0">{
                response.Headers = make(map[string]string)
        }</span>
        <span class="cov0" title="0">for k, v := range commonHeaders </span><span class="cov0" title="0">{
                // Only set if not already set by the handler to allow overrides
                if _, ok := response.Headers[k]; !ok </span><span class="cov0" title="0">{
                        response.Headers[k] = v
                }</span>
        }

        <span class="cov0" title="0">return response, nil</span>
}

func handleRootGet(_ events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        return utils.APIResponse(http.StatusOK, map[string]string{"message": "Welcome to the Go Lambda API"})
}</span>

func handleCreateUser(
        ctx context.Context, request events.APIGatewayProxyRequest, userRepo models.UserRepository,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        userHandler := handlers.NewUserHandler(userRepo)

        return userHandler.CreateUserHandler(ctx, request)
}</span>

func handleGetUser(
        ctx context.Context, request events.APIGatewayProxyRequest, userRepo models.UserRepository,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        userHandler := handlers.NewUserHandler(userRepo)

        return userHandler.GetUserHandler(ctx, request)
}</span>

func handleGetAllUsers(
        ctx context.Context, request events.APIGatewayProxyRequest, userRepo models.UserRepository,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        userHandler := handlers.NewUserHandler(userRepo)

        return userHandler.GetAllUsersHandler(ctx, request)
}</span>

func handleUpdateUser(
        ctx context.Context, request events.APIGatewayProxyRequest, userRepo models.UserRepository,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        userHandler := handlers.NewUserHandler(userRepo)

        return userHandler.UpdateUserHandler(ctx, request)
}</span>

func handleDeleteUser(
        ctx context.Context, request events.APIGatewayProxyRequest, userRepo models.UserRepository,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        userHandler := handlers.NewUserHandler(userRepo)

        return userHandler.DeleteUserHandler(ctx, request)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "go-lambda-api/internal/app"
)

func main() <span class="cov0" title="0">{
        // Set environment variable to trigger local server mode
        // os.Setenv("GO_RUN_MAIN", "1") // Removed to allow Lambda path testing

        // Call the AppMain function from the app package
        app.Main()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "context"
        "net/http"

        "go-lambda-api/utils"

        "github.com/aws/aws-lambda-go/events"
)

// HealthHandler struct for health check operations.
type HealthHandler struct{}

// NewHealthHandler creates and returns a new HealthHandler.
func NewHealthHandler() *HealthHandler <span class="cov0" title="0">{
        return &amp;HealthHandler{}
}</span>

// GetHealthHandler returns a 200 OK response for health checks.
func (h *HealthHandler) GetHealthHandler(
        ctx context.Context,
        request events.APIGatewayProxyRequest,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        return utils.APIResponse(http.StatusOK, map[string]string{"message": "Health Check OK"})
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"
        "time"

        "github.com/aws/aws-lambda-go/events"
        "github.com/google/uuid"

        "go-lambda-api/models"
        "go-lambda-api/utils"
)

// UserHandler struct holds the UserRepository interface.
type UserHandler struct {
        Repo models.UserRepository
}

// NewUserHandler creates a new UserHandler.
func NewUserHandler(userRepo models.UserRepository) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{Repo: userRepo}
}</span>

func (h *UserHandler) CreateUserHandler(
        ctx context.Context, request events.APIGatewayProxyRequest,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        var userReq models.UserRequest

        if err := json.Unmarshal([]byte(request.Body), &amp;userReq); err != nil </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">if err := userReq.Validate(false); err != nil </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">newUser := models.User{
                ID:        uuid.New().String(),
                Name:      userReq.Name,
                Email:     userReq.Email,
                CreatedAt: time.Now(),
        }

        createdUser, err := h.Repo.CreateUser(newUser)
        if err != nil </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return utils.APIResponse(http.StatusCreated, createdUser)</span>
}

func (h *UserHandler) GetUserHandler(
        ctx context.Context, request events.APIGatewayProxyRequest,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        userID := request.PathParameters["id"]
        if userID == "" </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusBadRequest, errors.New("user ID is required"))
        }</span>

        <span class="cov0" title="0">user, err := h.Repo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusNotFound, err)
        }</span>

        <span class="cov0" title="0">return utils.APIResponse(http.StatusOK, user)</span>
}

func (h *UserHandler) GetAllUsersHandler(
        ctx context.Context, request events.APIGatewayProxyRequest,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        userList := h.Repo.GetAllUsers()

        return utils.APIResponse(http.StatusOK, userList)
}</span>

func (h *UserHandler) UpdateUserHandler(
        ctx context.Context, request events.APIGatewayProxyRequest,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        userID := request.PathParameters["id"]
        if userID == "" </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusBadRequest, errors.New("user ID is required"))
        }</span>

        <span class="cov0" title="0">var userReq models.UserRequest
        if err := json.Unmarshal([]byte(request.Body), &amp;userReq); err != nil </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">if err := userReq.Validate(true); err != nil </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">existingUser, err := h.Repo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusNotFound, err)
        }</span>

        <span class="cov0" title="0">if userReq.Name != "" </span><span class="cov0" title="0">{
                existingUser.Name = userReq.Name
        }</span>
        <span class="cov0" title="0">if userReq.Email != "" </span><span class="cov0" title="0">{
                existingUser.Email = userReq.Email
        }</span>

        <span class="cov0" title="0">updatedUser, err := h.Repo.UpdateUser(existingUser)
        if err != nil </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return utils.APIResponse(http.StatusOK, updatedUser)</span>
}

func (h *UserHandler) DeleteUserHandler(
        ctx context.Context, request events.APIGatewayProxyRequest,
) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        userID := request.PathParameters["id"]
        if userID == "" </span><span class="cov0" title="0">{
                return utils.ErrorResponse(http.StatusBadRequest, errors.New("user ID is required"))
        }</span>

        <span class="cov0" title="0">err := h.Repo.DeleteUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "user not found" </span><span class="cov0" title="0">{
                        return utils.ErrorResponse(http.StatusNotFound, err)
                }</span>

                <span class="cov0" title="0">return utils.ErrorResponse(http.StatusInternalServerError, err)</span>
        }

        <span class="cov0" title="0">return utils.APIResponse(http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        localLambda "go-lambda-api/cmd/lambda"
        "go-lambda-api/handlers"
        "go-lambda-api/models"

        "github.com/aws/aws-lambda-go/events"
        aws_lambda "github.com/aws/aws-lambda-go/lambda"
        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/dynamodb"
        "github.com/aws/aws-sdk-go/service/dynamodb/dynamodbiface"
        "github.com/joho/godotenv"
)

// NewDB returns a new DynamoDB client
func NewDB() dynamodbiface.DynamoDBAPI <span class="cov0" title="0">{
        // Load environment variables from .env file
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Could not load .env file, assuming production environment: %v", err)
        }</span>

        // Use the AWS_REGION environment variable, if available
        <span class="cov0" title="0">awsRegion := os.Getenv("AWS_REGION")
        if awsRegion == "" </span><span class="cov0" title="0">{
                awsRegion = "us-east-1" // Default to us-east-1 if not set
        }</span>

        <span class="cov0" title="0">sess, err := session.NewSession(&amp;aws.Config{
                Region: aws.String(awsRegion),
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error creating AWS session: %v", err)
        }</span>

        <span class="cov0" title="0">return dynamodb.New(sess)</span>
}

// Main is the entry point for the application.
// It determines whether to run as a local server or a Lambda function.
func Main() <span class="cov0" title="0">{
        // Load environment variables from .env file
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Could not load .env file, assuming production environment: %v", err)
        }</span>

        <span class="cov0" title="0">if os.Getenv("LOCAL_SERVER") == "true" </span><span class="cov0" title="0">{
                startLocalServer()
        }</span> else<span class="cov0" title="0"> {
                startLambda()
        }</span>
}

func startLocalServer() <span class="cov0" title="0">{
        log.Println("Starting local server...")

        dbClient := NewDB()
        userRepo := models.NewDynamoDBUserRepository(dbClient, os.Getenv("DYNAMODB_TABLE_NAME"))

        healthHandler := handlers.NewHealthHandler()

        r := http.NewServeMux()

        r.HandleFunc("GET /health", adapt(healthHandler.GetHealthHandler))
        r.HandleFunc("POST /users", adapt(handlers.NewUserHandler(userRepo).CreateUserHandler))
        r.HandleFunc("GET /users/{id}", adapt(handlers.NewUserHandler(userRepo).GetUserHandler))
        r.HandleFunc("GET /users", adapt(handlers.NewUserHandler(userRepo).GetAllUsersHandler))
        r.HandleFunc("PUT /users/{id}", adapt(handlers.NewUserHandler(userRepo).UpdateUserHandler))
        r.HandleFunc("DELETE /users/{id}", adapt(handlers.NewUserHandler(userRepo).DeleteUserHandler))

        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:    ":" + port,
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                fmt.Printf("Local server listening on port %s\n", port)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Could not listen on %s: %v\n", port, err)
                }</span>
        }()

        // Graceful shutdown
        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)
        &lt;-stop

        log.Println("Shutting down server...")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server shutdown failed: %v", err)
        }</span>
        <span class="cov0" title="0">log.Println("Server gracefully stopped.")</span>
}

func startLambda() <span class="cov0" title="0">{
        log.Println("Starting Lambda function...")

        dbClient := NewDB()
        userRepo := models.NewDynamoDBUserRepository(dbClient, os.Getenv("DYNAMODB_TABLE_NAME"))
        healthHandler := handlers.NewHealthHandler()

        aws_lambda.Start(func(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) </span><span class="cov0" title="0">{
                return localLambda.Router(ctx, request, userRepo, healthHandler.GetHealthHandler)
        }</span>)
}

type apiGatewayHandler func(context.Context, events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error)

// adapt converts a standard http.HandlerFunc to an apiGatewayHandler signature
// This allows reusing handler logic designed for Lambda with a local HTTP server.
func adapt(handler apiGatewayHandler) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Convert http.Request to APIGatewayProxyRequest
                apiReq := events.APIGatewayProxyRequest{
                        Path:                  r.URL.Path,
                        HTTPMethod:            r.Method,
                        Headers:               make(map[string]string),
                        QueryStringParameters: make(map[string]string),
                        PathParameters:        make(map[string]string),
                }

                for name, values := range r.Header </span><span class="cov0" title="0">{
                        if len(values) &gt; 0 </span><span class="cov0" title="0">{
                                apiReq.Headers[name] = values[0]
                        }</span>
                }

                <span class="cov0" title="0">for name, values := range r.URL.Query() </span><span class="cov0" title="0">{
                        if len(values) &gt; 0 </span><span class="cov0" title="0">{
                                apiReq.QueryStringParameters[name] = values[0]
                        }</span>
                }

                // Extract path parameters (simple example, might need more robust parsing)
                <span class="cov0" title="0">if r.PathValue("id") != "" </span><span class="cov0" title="0">{
                        apiReq.PathParameters["id"] = r.PathValue("id")
                }</span>

                // Execute the Lambda handler
                <span class="cov0" title="0">apiResp, err := handler(r.Context(), apiReq)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                // Write response back to http.ResponseWriter
                <span class="cov0" title="0">for key, value := range apiResp.Headers </span><span class="cov0" title="0">{
                        w.Header().Set(key, value)
                }</span>
                <span class="cov0" title="0">w.WriteHeader(apiResp.StatusCode)
                _, err = w.Write([]byte(apiResp.Body))
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing response: %v", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "errors"
        "fmt"
        "time"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/dynamodb"
        "github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
        "github.com/aws/aws-sdk-go/service/dynamodb/dynamodbiface"
)

type User struct {
        ID        string    `json:"id"`
        Name      string    `json:"name"`
        Email     string    `json:"email"`
        CreatedAt time.Time `json:"created_at,omitempty"`
}

type UserRequest struct {
        Name  string `json:"name"`
        Email string `json:"email"`
}

func (ur *UserRequest) Validate(isUpdate bool) error <span class="cov0" title="0">{
        if !isUpdate </span><span class="cov0" title="0">{
                if ur.Name == "" </span><span class="cov0" title="0">{
                        return errors.New("name is required")
                }</span>
                <span class="cov0" title="0">if ur.Email == "" </span><span class="cov0" title="0">{
                        return errors.New("email is required")
                }</span>
        } else<span class="cov0" title="0"> if ur.Name == "" &amp;&amp; ur.Email == "" </span><span class="cov0" title="0">{
                return errors.New("no fields to update")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UserRepository defines the interface for user data operations.
type UserRepository interface {
        CreateUser(user User) (User, error)
        GetUserByID(id string) (User, error)
        GetAllUsers() []User
        UpdateUser(user User) (User, error)
        DeleteUser(id string) error
}

// inMemoryUserRepository implements UserRepository using an in-memory map.
type inMemoryUserRepository struct {
        users map[string]User
}

// globalInMemoryUserRepository is the singleton instance for in-memory user storage.
var globalInMemoryUserRepository = &amp;inMemoryUserRepository{users: make(map[string]User)}

// NewInMemoryUserRepository creates a new instance of inMemoryUserRepository.
// nolint: ireturn
func NewInMemoryUserRepository() UserRepository <span class="cov0" title="0">{
        return globalInMemoryUserRepository
}</span>

// ClearInMemoryUsers clears the in-memory user store for testing.
func ClearInMemoryUsers() <span class="cov0" title="0">{
        globalInMemoryUserRepository.users = make(map[string]User)
}</span>

// ClearUsers clears the in-memory user store for testing.
func (r *inMemoryUserRepository) ClearUsers() <span class="cov0" title="0">{
        r.users = make(map[string]User)
}</span>

func (r *inMemoryUserRepository) GetUserByID(id string) (User, error) <span class="cov0" title="0">{
        user, exists := r.users[id]
        if !exists </span><span class="cov0" title="0">{
                return User{}, errors.New("user not found")
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *inMemoryUserRepository) GetAllUsers() []User <span class="cov0" title="0">{
        userList := make([]User, 0, len(r.users))
        for _, user := range r.users </span><span class="cov0" title="0">{
                userList = append(userList, user)
        }</span>

        <span class="cov0" title="0">return userList</span>
}

func (r *inMemoryUserRepository) CreateUser(user User) (User, error) <span class="cov0" title="0">{
        r.users[user.ID] = user

        return user, nil
}</span>

func (r *inMemoryUserRepository) UpdateUser(user User) (User, error) <span class="cov0" title="0">{
        _, exists := r.users[user.ID]
        if !exists </span><span class="cov0" title="0">{
                return User{}, errors.New("user not found")
        }</span>
        <span class="cov0" title="0">r.users[user.ID] = user

        return user, nil</span>
}

func (r *inMemoryUserRepository) DeleteUser(id string) error <span class="cov0" title="0">{
        _, exists := r.users[id]
        if !exists </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>
        <span class="cov0" title="0">delete(r.users, id)

        return nil</span>
}

// dynamoDBUserRepository implements UserRepository for DynamoDB.
type dynamoDBUserRepository struct {
        db        dynamodbiface.DynamoDBAPI
        tableName string
}

// NewDynamoDBUserRepository creates a new instance of dynamoDBUserRepository.
func NewDynamoDBUserRepository(db dynamodbiface.DynamoDBAPI, tableName string) UserRepository <span class="cov0" title="0">{
        return &amp;dynamoDBUserRepository{db: db, tableName: tableName}
}</span>

// CreateUser inserts a new user into DynamoDB.
func (r *dynamoDBUserRepository) CreateUser(user User) (User, error) <span class="cov0" title="0">{
        av, err := dynamodbattribute.MarshalMap(user)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("failed to marshal user: %w", err)
        }</span>

        <span class="cov0" title="0">input := &amp;dynamodb.PutItemInput{
                Item:      av,
                TableName: aws.String(r.tableName),
        }

        _, err = r.db.PutItem(input)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("failed to put item to DynamoDB: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByID retrieves a user from DynamoDB by ID.
func (r *dynamoDBUserRepository) GetUserByID(id string) (User, error) <span class="cov0" title="0">{
        input := &amp;dynamodb.GetItemInput{
                Key: map[string]*dynamodb.AttributeValue{
                        "ID": {
                                S: aws.String(id),
                        },
                },
                TableName: aws.String(r.tableName),
        }

        result, err := r.db.GetItem(input)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("failed to get item from DynamoDB: %w", err)
        }</span>

        <span class="cov0" title="0">if result.Item == nil </span><span class="cov0" title="0">{
                return User{}, errors.New("user not found")
        }</span>

        <span class="cov0" title="0">var user User
        err = dynamodbattribute.UnmarshalMap(result.Item, &amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("failed to unmarshal item: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetAllUsers retrieves all users from DynamoDB.
func (r *dynamoDBUserRepository) GetAllUsers() []User <span class="cov0" title="0">{
        input := &amp;dynamodb.ScanInput{
                TableName: aws.String(r.tableName),
        }

        result, err := r.db.Scan(input)
        if err != nil </span><span class="cov0" title="0">{
                // Log the error, but return an empty list as per the interface signature
                fmt.Printf("failed to scan items from DynamoDB: %v\n", err)
                return []User{}
        }</span>

        <span class="cov0" title="0">var users []User
        err = dynamodbattribute.UnmarshalListOfMaps(result.Items, &amp;users)
        if err != nil </span><span class="cov0" title="0">{
                // Log the error, but return an empty list
                fmt.Printf("failed to unmarshal scan items: %v\n", err)
                return []User{}
        }</span>

        <span class="cov0" title="0">return users</span>
}

// UpdateUser updates an existing user in DynamoDB.
func (r *dynamoDBUserRepository) UpdateUser(user User) (User, error) <span class="cov0" title="0">{
        av, err := dynamodbattribute.MarshalMap(user)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("failed to marshal user: %w", err)
        }</span>

        <span class="cov0" title="0">input := &amp;dynamodb.PutItemInput{
                Item:      av,
                TableName: aws.String(r.tableName),
        }

        _, err = r.db.PutItem(input)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("failed to update item in DynamoDB: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// DeleteUser deletes a user from DynamoDB by ID.
func (r *dynamoDBUserRepository) DeleteUser(id string) error <span class="cov0" title="0">{
        input := &amp;dynamodb.DeleteItemInput{
                Key: map[string]*dynamodb.AttributeValue{
                        "ID": {
                                S: aws.String(id),
                        },
                },
                TableName: aws.String(r.tableName),
        }

        _, err := r.db.DeleteItem(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete item from DynamoDB: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"

        "github.com/aws/aws-lambda-go/events"
)

var jsonMarshal = json.Marshal

// APIResponse generates a consistent APIGatewayProxyResponse.
func APIResponse(statusCode int, body interface{}) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        headers := map[string]string{"Content-Type": "application/json"}

        var respBody []byte
        var err error

        if body != nil </span><span class="cov0" title="0">{
                respBody, err = jsonMarshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return events.APIGatewayProxyResponse{
                                StatusCode:        http.StatusInternalServerError,
                                Headers:           headers,
                                MultiValueHeaders: map[string][]string{},
                                IsBase64Encoded:   false,
                                Body:              fmt.Sprintf(`{"error": "%s"}`, err.Error()),
                        }, fmt.Errorf("failed to marshal response body: %w", err)
                }</span>
        }

        <span class="cov0" title="0">response := events.APIGatewayProxyResponse{
                StatusCode:        statusCode,
                Headers:           headers,
                Body:              string(respBody),
                MultiValueHeaders: map[string][]string{},
                IsBase64Encoded:   false,
        }

        EnsureHeaders(&amp;response)

        return response, nil</span>
}

// ErrorResponse generates a consistent error APIGatewayProxyResponse.
func ErrorResponse(statusCode int, err error) (events.APIGatewayProxyResponse, error) <span class="cov0" title="0">{
        errMessage := ""
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: %v", err.Error())
                errMessage = err.Error()
        }</span>

        <span class="cov0" title="0">respBody, jsonErr := jsonMarshal(map[string]string{"error": errMessage})
        if jsonErr != nil </span><span class="cov0" title="0">{
                // Fallback if marshaling error also fails
                return events.APIGatewayProxyResponse{StatusCode: http.StatusInternalServerError, Body: "{\"error\": \"failed to marshal error response\"}"}, nil
        }</span>

        <span class="cov0" title="0">response := events.APIGatewayProxyResponse{
                StatusCode: statusCode,
                Body:       string(respBody),
                Headers:    map[string]string{"Content-Type": "application/json"},
        }

        EnsureHeaders(&amp;response)

        return response, nil</span>
}

// EnsureHeaders ensures that essential headers are present in the response.
func EnsureHeaders(response *events.APIGatewayProxyResponse) <span class="cov0" title="0">{
        if response.Headers == nil </span><span class="cov0" title="0">{
                response.Headers = make(map[string]string)
        }</span>

        <span class="cov0" title="0">if _, ok := response.Headers["Content-Type"]; !ok </span><span class="cov0" title="0">{
                response.Headers["Content-Type"] = "application/json"
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
